"""
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Mark N. Read, 2017.


Entry point into package, various means of building profiles supplied directories of data

This module builds a statistical motility profile based of motility data.
It has been tailored towards IMARIS imaging software but functions for any data that adheres to the required format.
See the sample_data folder.


Can be imported into another module and run as follows:
"
import build
build_profile("<directory to the data>", True)  # this will draw graphs.
"

But can also be run from the terminal:

$> python -m motility_analysis.build <directory fo data>

It grabs the data from the supplied directory. There are no restrictions on what the directory is named, and likewise
the csv files contained therein. These csv files are generated by Imaris, and the last parts of their names should
not be changed. Examine the code below to see what these non-changeable parts of the file names are.

The "position" data should be in the following format:

"
Position X,Position Y,Position Z,Unit,Collection,TimePointID,TrackID
115.1454896,162.2476097,98.50877878,um,Position,5,1
154.3575272,196.4421448,98.2871678,um,Position,32,2
154.3245072,196.4862001,98.37096545,um,Position,33,2
151.1507156,202.7950181,97.84690447,um,Position,36,3
150.9904777,202.2180164,96.52494084,um,Position,37,3
154.0484613,198.8845198,95.84142955,um,Position,38,3
158.0649579,198.1317421,95.93310051,um,Position,39,3
160.2271328,194.1656305,96.57457785,um,Position,40,3
155.7120144,197.0925615,95.21001542,um,Position,41,3
... and so on ...
"
TimePointID must start from 1, not zero.


The "TimeIndex" data should be in this format:
"
Time_Min
0.0
0.5
1.0
1.5
2.0
2.5
3.0
3.5
4.0
4.5
"

This is all fairly easily altered if your data is in another format.

Mark N. Read, 2019
"""
from . import profile
from . import graphing
from . import track
import fnmatch
import numpy as np
import os
import pandas
import sys


def load_tracks(directory, interpolate=False, timestep_s=None, fmi_direction=None):
    """
    Loads track data from the file system for a specific directory. No quality filtering (min displacements or
    observations) is performed, though interpolation (as a straight line, constant speed) can be applied if there are
    missing observations in the track. This can happen if IMARIS does not perform the interpolation.

    :param directory: filesystem location to load tracks from.
    :param interpolate:
    :param timestep_s:
    :return: dictionary of Track objects, indexed by their ID in the profile.
    """
    print('Loading tracks from directory ' + directory)
    tracks = dict()  # stores Track objects in a dictionary, using their IDs as keys.
    files = os.listdir(directory)

    if not timestep_s:
        time_found = False
        for f in files:
            if fnmatch.fnmatch(f, '*_TimeIndex.csv'):
                time_found = True
                data_file = os.path.join(directory, f)
                data = np.genfromtxt(data_file, delimiter=',', skip_header=0)
                # Convert dur (minutes) to seconds.. -1 because first entry is time zero.
                timestep_s = (data[2] - data[1]) * 60.  # convert from minutes to seconds
                break  # nOo point looking at any more files.
            if fnmatch.fnmatch(f, '*_TimeStepMin.txt'):
                time_found = True
                data_file = os.path.join(directory, f)
                data = np.genfromtxt(data_file)
                timestep_s = float(data * 60.)
                break
            if fnmatch.fnmatch(f, '*_TimeStepSec.txt'):
                time_found = True
                data_file = os.path.join(directory, f)
                data = np.genfromtxt(data_file)
                timestep_s = float(data)
                break
        if not time_found:
            raise Exception('Time step size has not been provided.')
        print('time step in seconds : ' + str(timestep_s))

    data_file = None
    for f in files:
        # Allows files to have a user-specified prefix, common practice in imaging is to include experimental metadata
        # in the file name
        if fnmatch.fnmatch(f, '*_Position.csv'):
            data_file = os.path.join(directory, f)
            print('loading position data from file {:s}'.format(data_file))
            break
    if data_file:  # Check that file has been found
        position_data = pandas.read_csv(data_file, sep=',', index_col=False)
        # Ensure that data is input in monotonically increasing time. (And then by track ID for elegance)
        position_data.sort_values(by=['TrackID', 'TimePointID'], axis='index', inplace=True)
        # Rename the columns, if needed. Method is robust to not finding these columns (e.g. if already no spaces)
        position_data.rename(index=str, inplace=True, columns={'Position X': 'Position_X',
                                                               'Position Y': 'Position_Y',
                                                               'Position Z': 'Position_Z'})
        for row in position_data.index:
            ident = position_data.loc[row, 'TrackID']
            if np.isnan(ident):
                print('Warning, found positional data with no ID. Omitting this data point.')
            else:
                x = position_data.loc[row, 'Position_X']
                y = position_data.loc[row, 'Position_Y']
                z = position_data.loc[row, 'Position_Z']

                # A count from 1, identifying the iteration. These need not be continuous if IMARIS temporarily loses a cell
                timeIter = position_data.loc[
                    row, 'TimePointID']  # Integer referring to the sample number (ie, not minutes)
                # timeIter = position_data['TimePointID'][row]  # Integer referring to the sample number (ie, not minutes)

                time = (timeIter - 1) * timestep_s  # '-1' because iteration count starts from 1, not 0.
                if ident not in tracks:  # First time encountering this track
                    tracks[ident] = track.Track(ident, timestep_s=timestep_s)

                if time is not None and x is not None and y is not None and z is not None:
                    # Prevent crashing if empty lines in the file.
                    tracks[ident].log_position(x, y, z, time, timeIter)

        # Complete dataset now read in; calculate summary statistics.
        print('Calculating summary stats for tracks')
        for t in tracks.values():
            print('Calculating summary statistics for track: ' + str(t.ID))
            t.summary_stats(interpolate=interpolate, fmi_direction=fmi_direction)
    if not tracks:
        raise Exception('Found no tracks in directory ' + directory)
    return tracks


def build_profile(directory=None, graphs=False, trim_displacement=False, trim_observations=None, trim_duration=None,
                  trim_arrest_coefficient=None, tracks=None, analyse_teleports=False, interpolate=True,
                  timestep_s=None, fmi_direction=None, style="dark"):
    """
    Create a profile. Can be done by supplying the directory (in which case made tracks None), or can be
    done by supplying the tracks directly. If supplying a directory, all tracks contained therein need to have the same
    timestep. If supplying as tracks, the timestep may vary (e.g. if data comes from several experiments) and
    the timestep_s parameter should not be supplied.

    :param directory: supply in place of tracks.
    :param graphs:
    :param trim_displacement: float, minimum displacement for a track to be retained in profile
    :param trim_observations: int, minimum number of observations for a track to be retained in profile
    :param trim_duration: float, minimum duration for which a track is tracked, in minutes
    :param tracks: a dictionary of Track objects, indexed by their ID in the data file.
    :param analyse_teleports: if True identifies tracks that appear or disappear in the middle of the volume (ie, not
     by migrating out of the imaging volume). This was added to sanity check IMARIS data, where it looked like tracks
     were being lost.
    :param interpolate: fills in any gaps in a track's recorded motility through linear interpolation (constant speed
     in a straight line). IMARIS can temporarily lose tracks, e.g. because of weak signal.
    :param timestep_s: timestep of experiment in seconds. This is an optional parameter.
    :return: a Profile object
    """
    if not (directory or tracks):
        raise Exception("Must supply either tracks or a directory from which to build a Profile.")

    assert directory or tracks  # One of these must be supplied
    if not tracks:
        # Tracks have not been supplied, hence load data from filesystem.
        print('Compiling profile for directory ' + str(directory) + ', No tracks were supplied.')
        tracks = load_tracks(directory, interpolate, timestep_s=timestep_s, fmi_direction=fmi_direction)

    all_tracks = None
    if isinstance(tracks, dict):
        all_tracks = tracks.values()
    else:
        all_tracks = tracks
    all_data = profile.Profile(
        all_tracks, trim_displacement=trim_displacement, trim_observations=trim_observations,
        trim_duration=trim_duration, trim_arrest_coefficient=trim_arrest_coefficient,
        analyse_teleports=analyse_teleports)

    # Plot graphs, if user has requested it.
    if graphs:
        graph_dir = directory + '/motility_profile'
        os.makedirs(graph_dir, exist_ok=True)
        graphing.plot_profile_graphs([all_data], directory=graph_dir, style=style)
        print('finished creating profile for directory ' + directory)
    return all_data


def main():
    """
    Until this is moved into scripts directory, call as :
    #> cd path/motility_analysis   (this is the parent directory)
    #> python -m motility_analysis.profile data-directory
    """
    import glob

    directory = sys.argv[1]  # First command line argument is name of script called.
    if '-o' in sys.argv:
        output_dir = sys.argv[sys.argv.index('-o')+1]
    else:
        output_dir = directory

    reps = glob.glob(directory + '/rep*')
    reps = [r for r in reps if os.path.isdir(r)]
    profiles = []
    if not reps:
        p = build_profile(directory, graphs=False, interpolate=True)
        profiles = [p]
        graphing.plot_profile_graphs(profiles, output_dir)
        # p.check_for_duplicates()
    else:
        print('found multiple replicate experiments, processing them all in batch.')
        for r in reps:
            profiles.append(build_profile(r, graphs=False, interpolate=True))
        graphing.plot_profile_graphs(profiles, output_dir)
    # graphing.analyse_broken_path_biases(profiles, directory)


if __name__ == '__main__':
    main()